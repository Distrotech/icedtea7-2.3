diff -r ad4c46e70192 src/cpu/zero/vm/asm_helper.cpp
--- openjdk/hotspot/src/cpu/zero/vm/asm_helper.cpp	Tue Mar 11 15:45:00 2014 +0000
+++ openjdk/hotspot/src/cpu/zero/vm/asm_helper.cpp	Wed Mar 12 13:34:40 2014 +0000
@@ -23,6 +23,10 @@
 #define ARCH_VFP	(1<<17)
 #define ARCH_CLZ	(1<<18)
 
+/* A workaround for private and protected fields */
+#define private   public
+#define protected public
+
 #include "precompiled.hpp"
 #include "asm/assembler.hpp"
 #include "interp_masm_zero.hpp"
@@ -33,8 +37,10 @@
 #include "oops/methodDataOop.hpp"
 #include "oops/methodOop.hpp"
 #include "oops/oop.inline.hpp"
+#include "oops/klassOop.hpp"
 #include "prims/jvmtiExport.hpp"
 #include "prims/jvmtiThreadState.hpp"
+#include "runtime/frame.hpp"
 #include "runtime/deoptimization.hpp"
 #include "runtime/frame.inline.hpp"
 #include "runtime/sharedRuntime.hpp"
@@ -68,11 +74,22 @@
 // particular method.
 #define NAME1 "sun.nio.ch.FileChannelImpl$Unmapper.run()V"
 #define EQ(S1, S2) (S1 && (strncmp(S1, S2, strlen(S2)) == 0))
-extern "C" void my_trace(void *jpc, void *istate)
+extern "C" void my_trace(void *jpc, interpreterState istate)
 {
-  char *name = meth((interpreterState)istate);
-  if (EQ(name, NAME1));
-    asm volatile("nop");  // Somewhere to put a breakpoint
+  JavaThread *jt = istate->thread();
+  if (jt->zero_stack()->sp() && jt->top_zero_frame()) {
+    bool has_last_Java_frame = jt->has_last_Java_frame();
+    if (!has_last_Java_frame)
+      jt->set_last_Java_frame();
+
+    StackFrameStream sfs(jt);
+    for(int i = 0; !sfs.is_done(); sfs.next(), i++) {
+    }
+
+    // Reset the frame anchor if necessary
+    if (!has_last_Java_frame)
+      jt->reset_last_Java_frame();
+  }
 }
 
 extern "C" unsigned hwcap(void)
@@ -603,7 +620,7 @@
   print_def("CONSTANTPOOL_CACHE", offset_of(constantPoolOopDesc, _cache));
   print_def("CONSTANTPOOL_POOL_HOLDER", offset_of(constantPoolOopDesc, _pool_holder));
   print_def("CONSTANTPOOL_BASE", sizeof(constantPoolOopDesc));
-  print_def("CP_CACHE_VOLATILE_FIELD_FLAG_BIT", ConstantPoolCacheEntry::volatileField);
+  print_def("CP_CACHE_VOLATILE_FIELD_FLAG_BIT", ConstantPoolCacheEntry::is_volatile_shift);
   print_def("CP_CACHE_FLAGS", offset_of(ConstantPoolCacheEntry, _flags));
   nl();
   print_def("CP_OFFSET", in_bytes(constantPoolCacheOopDesc::base_offset()));
@@ -704,10 +721,10 @@
 	print_def("class_fully_initialized",	instanceKlass::fully_initialized);
 	print_def("class_init_error",		instanceKlass::initialization_error);
 	nl();
-	print_def("flag_methodInterface",	1 << ConstantPoolCacheEntry::methodInterface);
-	print_def("flag_volatileField",		1 << ConstantPoolCacheEntry::volatileField);
-	print_def("flag_vfinalMethod",		1 << ConstantPoolCacheEntry::vfinalMethod);
-	print_def("flag_finalField",		1 << ConstantPoolCacheEntry::finalField);
+	print_def("flag_methodInterface",	1 << ConstantPoolCacheEntry::has_method_type_shift);
+	print_def("flag_volatileField",		1 << ConstantPoolCacheEntry::is_volatile_shift);
+	print_def("flag_vfinalMethod",		1 << ConstantPoolCacheEntry::is_vfinal_shift);
+	print_def("flag_finalField",		1 << ConstantPoolCacheEntry::is_final_shift);
 	nl();
 	print_def("INVOCATIONCOUNTER_COUNTINCREMENT", InvocationCounter::count_increment);
 	nl();
diff -r ad4c46e70192 src/cpu/zero/vm/bytecodes_arm.def
--- openjdk/hotspot/src/cpu/zero/vm/bytecodes_arm.def	Tue Mar 11 15:45:00 2014 +0000
+++ openjdk/hotspot/src/cpu/zero/vm/bytecodes_arm.def	Wed Mar 12 13:34:40 2014 +0000
@@ -1950,7 +1950,7 @@
 	str	r3, [thread, #THREAD_LAST_JAVA_SP]
 	ldr	r0, [istate, #ISTATE_METHOD]
 	ldr	r3, [r2, #0]
-	ldrh	r0, [r0, #40]
+	ldrh	r0, [r0, #METHOD_MAXLOCALS]
 	add	r1, r2, #4
 	str	r3, [thread, #THREAD_TOP_ZERO_FRAME]
 
@@ -1981,7 +1981,7 @@
 	str	r3, [thread, #THREAD_LAST_JAVA_SP]
 	ldr	r0, [istate, #ISTATE_METHOD]
 	ldr	r3, [stack, #0]
-	ldrh	r0, [r0, #40]
+	ldrh	r0, [r0, #METHOD_MAXLOCALS]
 
 	str	r3, [thread, #THREAD_TOP_ZERO_FRAME]
 	str	r1, [stack, r0, lsl #2]!
@@ -2008,7 +2008,7 @@
 	str	r3, [thread, #THREAD_LAST_JAVA_SP]
 	ldr	r0, [istate, #ISTATE_METHOD]
 	ldr	r3, [r2, #0]
-	ldrh	r0, [r0, #40]
+	ldrh	r0, [r0, #METHOD_MAXLOCALS]
 	add	r1, r2, #4
 	str	r3, [thread, #THREAD_TOP_ZERO_FRAME]
 
@@ -3993,7 +3996,7 @@
 	str	r3, [thread, #THREAD_LAST_JAVA_SP]
 	ldr	r0, [istate, #ISTATE_METHOD]
 	ldr	r3, [stack, #0]
-	ldrh	r0, [r0, #40]
+	ldrh	r0, [r0, #METHOD_MAXLOCALS]
 	str	r3, [thread, #THREAD_TOP_ZERO_FRAME]
 	str	r1, [stack, r0, lsl #2]!
 
@@ -4022,7 +4025,7 @@
 	str	r3, [thread, #THREAD_LAST_JAVA_SP]
 	ldr	r0, [istate, #ISTATE_METHOD]
 	ldr	r3, [stack, #0]
-	ldrh	r0, [r0, #40]
+	ldrh	r0, [r0, #METHOD_MAXLOCALS]
 	str	r3, [thread, #THREAD_TOP_ZERO_FRAME]
 	str	r1, [stack, r0, lsl #2]!
 
@@ -4429,7 +4432,7 @@
 	str	r3, [thread, #THREAD_LAST_JAVA_SP]
 	ldr	r0, [istate, #ISTATE_METHOD]
 	ldr	r3, [stack, #0]
-	ldrh	r0, [r0, #40]
+	ldrh	r0, [r0, #METHOD_MAXLOCALS]
 	str	r3, [thread, #THREAD_TOP_ZERO_FRAME]
 	str	r1, [stack, r0, lsl #2]!
 
diff -r ad4c46e70192 src/cpu/zero/vm/cppInterpreter_arm.S
--- openjdk/hotspot/src/cpu/zero/vm/cppInterpreter_arm.S	Tue Mar 11 15:45:00 2014 +0000
+++ openjdk/hotspot/src/cpu/zero/vm/cppInterpreter_arm.S	Wed Mar 12 13:34:40 2014 +0000
@@ -3431,7 +3444,7 @@
 	str	r3, [thread, #THREAD_LAST_JAVA_FP]
 	ldr	r0, [istate, #ISTATE_METHOD]
 	ldr	r3, [r2, #0]
-	ldrh	r0, [r0, #40]
+	ldrh	r0, [r0, #METHOD_MAXLOCALS]
 	add	r1, r2, #4
 	str	r3, [thread, #THREAD_TOP_ZERO_FRAME]
 
@@ -3560,7 +3573,7 @@
 	str	r3, [thread, #THREAD_LAST_JAVA_SP]
 	ldr	r0, [istate, #ISTATE_METHOD]
 	ldr	r3, [r2, #0]
-	ldrh	r0, [r0, #40]
+	ldrh	r0, [r0, #METHOD_MAXLOCALS]
 	add	r1, r2, #4
 	str	r3, [thread, #THREAD_TOP_ZERO_FRAME]
 
diff -r ad4c46e70192 src/cpu/zero/vm/cppInterpreter_zero.cpp
--- openjdk/hotspot/src/cpu/zero/vm/cppInterpreter_zero.cpp	Tue Mar 11 15:45:00 2014 +0000
+++ openjdk/hotspot/src/cpu/zero/vm/cppInterpreter_zero.cpp	Wed Mar 12 13:34:40 2014 +0000
@@ -1,6 +1,6 @@
 /*
- * Copyright (c) 2003, 2011, Oracle and/or its affiliates. All rights reserved.
- * Copyright 2007, 2008, 2009, 2010, 2011 Red Hat, Inc.
+ * Copyright (c) 2003, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2013 Red Hat, Inc.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -66,9 +66,10 @@
   CALL_VM_NOCHECK_NOFIX(func)                   \
   fixup_after_potential_safepoint()
 
-
-#ifdef z_CPPDEBUG
+//#define CPPIDEBUG 1
+#ifdef CPPIDEBUG
 #define CPPINT_DEBUG( Z_code_ ) Z_code_
+CPPINT_DEBUG ( static const char *FFng_Zero_Flag = "CPPINT_DEBUG_ON\n"; ) 
 #else
 #define CPPINT_DEBUG( Z_code_ )
 #endif
@@ -618,6 +619,25 @@
   return 0;
 }
 
+int CppInterpreter::method_handle_entry(methodOop method,
+                                        intptr_t UNUSED, TRAPS) {
+  JavaThread *thread = (JavaThread *) THREAD;
+  ZeroStack *stack = thread->zero_stack();
+  CPPINT_DEBUG( tty->print_cr( "method_handle : 0x%x , thread: 0x%x , stack: %0x%x.", \
+						method, thread, stack ); )
+
+  return MethodHandles::method_handle_entry_invokeBasic(method, UNUSED,  THREAD);
+}
+
+void CppInterpreter::process_method_handle(oop method_handle, TRAPS) {
+  JavaThread *thread = (JavaThread *) THREAD;
+  ZeroStack *stack = thread->zero_stack();
+  CPPINT_DEBUG( tty->print_cr( "process_method_handle : 0x%x , thread: 0x%x , stack: %0x%x.", \
+						method_handle, thread, stack ); )
+  methodOop method = (methodOop) java_lang_invoke_MemberName::vmtarget(method_handle);
+  MethodHandles::invoke_target(method, THREAD);
+}
+
 // The new slots will be inserted before slot insert_before.
 // Slots < insert_before will have the same slot number after the insert.
 // Slots >= insert_before will become old_slot + num_slots.
diff -r ad4c46e70192 src/cpu/zero/vm/cppInterpreter_zero.hpp
--- openjdk/hotspot/src/cpu/zero/vm/cppInterpreter_zero.hpp	Tue Mar 11 15:45:00 2014 +0000
+++ openjdk/hotspot/src/cpu/zero/vm/cppInterpreter_zero.hpp	Wed Mar 12 13:34:40 2014 +0000
@@ -1,6 +1,6 @@
 /*
- * Copyright (c) 1997, 2010, Oracle and/or its affiliates. All rights reserved.
- * Copyright 2007, 2008, 2010, 2011 Red Hat, Inc.
+ * Copyright (c) 1997, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2013 Red Hat, Inc.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -37,6 +37,7 @@
   static int accessor_entry(methodOop method, intptr_t UNUSED, TRAPS);
   static int empty_entry(methodOop method, intptr_t UNUSED, TRAPS);
   static int method_handle_entry(methodOop method, intptr_t UNUSED, TRAPS);
+  static void process_method_handle(oop method_handle, TRAPS);
 
  public:
   // Main loop of normal_entry
@@ -44,7 +45,6 @@
 
  private:
   // Helpers for method_handle_entry
-  static void process_method_handle(oop method_handle, TRAPS);
   static void insert_vmslots(int insert_before, int num_slots, TRAPS);
   static void remove_vmslots(int first_slot, int num_slots, TRAPS);
   static BasicType result_type_of_handle(oop method_handle);
diff -r ad4c46e70192 src/cpu/zero/vm/methodHandles_zero.hpp
--- openjdk/hotspot/src/cpu/zero/vm/methodHandles_zero.hpp	Tue Mar 11 15:45:00 2014 +0000
+++ openjdk/hotspot/src/cpu/zero/vm/methodHandles_zero.hpp	Wed Mar 12 13:34:40 2014 +0000
@@ -1,6 +1,6 @@
 /*
- * Copyright (c) 2011, Oracle and/or its affiliates. All rights reserved.
- * Copyright 2011, 2012 Red Hat, Inc.
+ * Copyright (c) 2011, 2013, Oracle and/or its affiliates. All rights reserved.
+ * Copyright 2013 Red Hat, Inc.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
@@ -29,10 +29,11 @@
   adapter_code_size = sizeof(ZeroEntry) * (Interpreter::method_handle_invoke_LAST - Interpreter::method_handle_invoke_FIRST + 1)
 };
 
+public:
+  static void invoke_target(methodOop method, TRAPS);
+  static int method_handle_entry_invokeBasic(methodOop method, intptr_t UNUSED, TRAPS);
 private:
   static oop popFromStack(TRAPS);
-  static void invoke_target(methodOop method, TRAPS);
-  static int method_handle_entry_invokeBasic(methodOop method, intptr_t UNUSED, TRAPS);
   static int method_handle_entry_linkToStaticOrSpecial(methodOop method, intptr_t UNUSED, TRAPS);
   static int method_handle_entry_linkToVirtual(methodOop method, intptr_t UNUSED, TRAPS);
   static int method_handle_entry_linkToInterface(methodOop method, intptr_t UNUSED, TRAPS);
diff -r ad4c46e70192 src/cpu/zero/vm/thumb2.cpp
--- openjdk/hotspot/src/cpu/zero/vm/thumb2.cpp	Tue Mar 11 15:45:00 2014 +0000
+++ openjdk/hotspot/src/cpu/zero/vm/thumb2.cpp	Wed Mar 12 13:34:40 2014 +0000
@@ -430,13 +430,15 @@
 
 #ifdef PRODUCT
 
-#define JASSERT(cond, msg)	0
+#define JASSERT(cond, msg)	
 #define J_Unimplemented() longjmp(compiler_error_env, COMPILER_RESULT_FATAL)
+#define JDEBUG_( _j_ )        
 
 #else
 
 #define JASSERT(cond, msg)	do { if (!(cond)) fatal(msg); } while (0)
 #define J_Unimplemented()       { report_unimplemented(__FILE__, __LINE__); BREAKPOINT; }
+#define JDEBUG_( _j_ )          _j_
 
 #endif // PRODUCT
 
@@ -4571,7 +4573,7 @@
   if (!cache->is_resolved((Bytecodes::Code)opc_getfield)) return 0;
 
   TosState tos_type = cache->flag_state();
-  int field_offset = cache->f2();
+  int field_offset = cache->f2_as_index();
 
   // Slow entry point - callee save
   // R0 = method
@@ -5886,7 +5890,7 @@
 	}
 
 	TosState tos_type = cache->flag_state();
-	int field_offset = cache->f2();
+	int field_offset = cache->f2_as_index();
 
 	if (tos_type == ltos || tos_type == dtos) {
 	  Reg r_lo, r_hi;
@@ -5949,7 +5953,8 @@
 	}
 
 	TosState tos_type = cache->flag_state();
-	int field_offset = cache->f2();
+	int field_offset = cache->f2_as_index();
+	JDEBUG_( tty->print("f2_as_index getstatic %d: %s: %s %d\n", index , name->as_C_string(), sig->as_C_string(), field_offset); );
 
 	if (tos_type == ltos || tos_type == dtos) {
 	  Reg r_lo, r_hi, r_addr;
@@ -6018,7 +6023,7 @@
 	  storeBarrier(jinfo->codebuf);
 
 	TosState tos_type = cache->flag_state();
-	int field_offset = cache->f2();
+	int field_offset = cache->f2_as_index();
 
 	if (tos_type == ltos || tos_type == dtos) {
 	  Reg r_lo, r_hi;
@@ -6083,7 +6088,7 @@
 	  storeBarrier(jinfo->codebuf);
 
 	TosState tos_type = cache->flag_state();
-	int field_offset = cache->f2();
+	int field_offset = cache->f2_as_index();
 	Reg r_obj;
 
 	if (tos_type == ltos || tos_type == dtos) {
@@ -6163,7 +6168,7 @@
 	  break;
 	}
 
-	callee = opcode == opc_invokevirtual ? (methodOop)cache->f2() : (methodOop)cache->f1();
+	callee = opcode == opc_invokevirtual ? (methodOop)cache->f2_as_index() : (methodOop)cache->f1_as_instance();
 
 	if (opcode != opc_invokevirtual || cache->is_vfinal()) {
 	  if (handle_special_method(callee, jinfo, stackdepth))
@@ -6181,7 +6186,7 @@
 	    JASSERT(cache->parameter_size() == 1, "not 1 parameter to accessor");
 
 	    TosState tos_type = entry->flag_state();
-	    int field_offset = entry->f2();
+	    int field_offset = entry->f2_as_index();
 
 	    JASSERT(tos_type == btos || tos_type == ctos || tos_type == stos || tos_type == atos || tos_type == itos, "not itos or atos");
 
@@ -6228,7 +6233,7 @@
 	  ldr_imm(jinfo->codebuf, ARM_R0, ARM_R0,
 		CP_OFFSET + (index << 4) + (opcode == opc_invokevirtual ? 8 : 4), 1, 0);
 	else
-	  ldr_imm(jinfo->codebuf, ARM_R0, ARM_R3, INSTANCEKLASS_VTABLE_OFFSET + cache->f2() * 4, 1, 0);
+	  ldr_imm(jinfo->codebuf, ARM_R0, ARM_R3, INSTANCEKLASS_VTABLE_OFFSET + cache->f2_as_index() * 4, 1, 0);
 	add_imm(jinfo->codebuf, ARM_R2, ARM_R2, bci+CONSTMETHOD_CODEOFFSET);
  	str_imm(jinfo->codebuf, ARM_R1, Rthread, THREAD_LAST_JAVA_SP, 1, 0);
 	str_imm(jinfo->codebuf, ARM_R1, Rthread, THREAD_LAST_JAVA_FP, 1, 0);
@@ -6298,7 +6303,7 @@
 	  int r = JSTACK_REG(jstack);
 	  PUSH(jstack, r);
 	  ldr_imm(jinfo->codebuf, r, Ristate, ISTATE_CONSTANTS, 1, 0);
-	  ldr_imm(jinfo->codebuf, r, r, CP_OFFSET + (index << 4) + 4, 1, 0); // offset to cache->f1()
+	  ldr_imm(jinfo->codebuf, r, r, CP_OFFSET + (index << 4) + 4, 1, 0); // offset to cache->f1_as_instance()
 	} else {
 	  Thumb2_Exit(jinfo, H_EXIT_TO_INTERPRETER, bci, stackdepth);
 	}
